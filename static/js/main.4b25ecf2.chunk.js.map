{"version":3,"sources":["App.jsx","index.js"],"names":["sdk","ThirdwebSDK","bundleDropModule","getBundleDropModule","tokenModule","getTokenModule","voteModule","getVoteModule","App","useWeb3","connectWallet","address","provider","error","console","log","signer","getSigner","undefined","useState","hasClaimedNFT","setHasClaimedNFT","isClaiming","setIsClaiming","memberTokenAmounts","setMemberTokenAmounts","memberAddresses","setMemberAddresses","proposals","setProposals","isVoting","setIsVoting","hasVoted","setHasVoted","useEffect","getAll","then","catch","err","length","proposalId","getAllClaimerAddresses","addresess","getAllHolderBalances","amounts","memberList","useMemo","map","tokenAmount","ethers","utils","formatUnits","setProviderOrSigner","balanceOf","balance","gt","className","onClick","member","str","substring","onSubmit","e","a","preventDefault","stopPropagation","votes","proposal","voteResult","vote","forEach","document","getElementById","type","checked","getDelegationOf","constants","AddressZero","delegateTo","Promise","all","get","state","execute","index","description","id","name","value","defaultChecked","htmlFor","label","disabled","claim","finally","ReactDOM","render","StrictMode","connectors","injected","supportedChainIds"],"mappings":"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","file":"static/js/main.4b25ecf2.chunk.js","sourcesContent":["import { useEffect, useMemo, useState } from \"react\";\nimport { ethers } from \"ethers\";\nimport { useWeb3 } from \"@3rdweb/hooks\";\nimport { ThirdwebSDK } from \"@3rdweb/sdk\";\n\nconst sdk = new ThirdwebSDK(\"rinkeby\");\n\nconst bundleDropModule = sdk.getBundleDropModule(\n    \"0x53495ad5B23A21684b1b1BcA4BC75f285AfbF972\",\n);\nconst tokenModule = sdk.getTokenModule(\n    \"0xb0b28865A88ec07f96c89E175a91A0e65E6Faf8c\",\n);\n\nconst voteModule = sdk.getVoteModule(\n    \"0xf5D913825D961bC02DcF9cE382d68Dbf744381f2\",\n);\n\nconst App = () => {\n    const { connectWallet, address, error, provider } = useWeb3();\n    console.log(\"üëã Address:\", address)\n\n    // The signer is required to sign transactions on the blockchain.\n    // Without it we can only read data, not write.\n    const signer = provider ? provider.getSigner() : undefined;\n\n    const [hasClaimedNFT, setHasClaimedNFT] = useState(false);\n    // isClaiming lets us easily keep a loading state while the NFT is minting.\n    const [isClaiming, setIsClaiming] = useState(false);\n    // Holds the amount of token each member has in state.\n    const [memberTokenAmounts, setMemberTokenAmounts] = useState({});\n// The array holding all of our members addresses.\n    const [memberAddresses, setMemberAddresses] = useState([]);\n\n    const [proposals, setProposals] = useState([]);\n    const [isVoting, setIsVoting] = useState(false);\n    const [hasVoted, setHasVoted] = useState(false);\n\n// Retreive all our existing proposals from the contract.\n    useEffect(() => {\n        if (!hasClaimedNFT) {\n            return;\n        }\n        // A simple call to voteModule.getAll() to grab the proposals.\n        voteModule\n            .getAll()\n            .then((proposals) => {\n                // Set state!\n                setProposals(proposals);\n                console.log(\"üåà Proposals:\", proposals)\n            })\n            .catch((err) => {\n                console.error(\"failed to get proposals\", err);\n            });\n    }, [hasClaimedNFT]);\n\n// We also need to check if the user already voted.\n    useEffect(() => {\n        if (!hasClaimedNFT) {\n            return;\n        }\n\n        // If we haven't finished retreieving the proposals from the useEffect above\n        // then we can't check if the user voted yet!\n        if (!proposals.length) {\n            return;\n        }\n\n        // Check if the user has already voted on the first proposal.\n        voteModule\n            .hasVoted(proposals[0].proposalId, address)\n            .then((hasVoted) => {\n                setHasVoted(hasVoted);\n                console.log(\"ü•µ User has already voted\")\n            })\n            .catch((err) => {\n                console.error(\"failed to check if wallet has voted\", err);\n            });\n    }, [hasClaimedNFT, proposals, address]);\n\n// A fancy function to shorten someones wallet address, no need to show the whole thing.\n    const shortenAddress = (str) => {\n        return str.substring(0, 6) + \"...\" + str.substring(str.length - 4);\n    };\n\n// This useEffect grabs all our the addresses of our members holding our NFT.\n    useEffect(() => {\n        if (!hasClaimedNFT) {\n            return;\n        }\n\n        // Just like we did in the 7-airdrop-token.js file! Grab the users who hold our NFT\n        // with tokenId 0.\n        bundleDropModule\n            .getAllClaimerAddresses(\"0\")\n            .then((addresess) => {\n                console.log(\"üöÄ Members addresses\", addresess)\n                setMemberAddresses(addresess);\n            })\n            .catch((err) => {\n                console.error(\"failed to get member list\", err);\n            });\n    }, [hasClaimedNFT]);\n\n// This useEffect grabs the # of token each member holds.\n    useEffect(() => {\n        if (!hasClaimedNFT) {\n            return;\n        }\n\n        // Grab all the balances.\n        tokenModule\n            .getAllHolderBalances()\n            .then((amounts) => {\n                console.log(\"üëú Amounts\", amounts)\n                setMemberTokenAmounts(amounts);\n            })\n            .catch((err) => {\n                console.error(\"failed to get token amounts\", err);\n            });\n    }, [hasClaimedNFT]);\n\n// Now, we combine the memberAddresses and memberTokenAmounts into a single array\n    const memberList = useMemo(() => {\n        return memberAddresses.map((address) => {\n            return {\n                address,\n                tokenAmount: ethers.utils.formatUnits(\n                    // If the address isn't in memberTokenAmounts, it means they don't\n                    // hold any of our token.\n                    memberTokenAmounts[address] || 0,\n                    18,\n                ),\n            };\n        });\n    }, [memberAddresses, memberTokenAmounts]);\n    // Another useEffect!\n    useEffect(() => {\n        // We pass the signer to the sdk, which enables us to interact with\n        // our deployed contract!\n        sdk.setProviderOrSigner(signer);\n    }, [signer]);\n\n    useEffect(() => {\n        if (!address) {\n            return;\n        }\n        return bundleDropModule\n            .balanceOf(address, \"0\")\n            .then((balance) => {\n                if (balance.gt(0)) {\n                    setHasClaimedNFT(true);\n                    console.log(\"üåü this user has a membership NFT!\")\n                } else {\n                    setHasClaimedNFT(false);\n                    console.log(\"üò≠ this user doesn't have a membership NFT.\")\n                }\n            })\n            .catch((error) => {\n                setHasClaimedNFT(false);\n                console.error(\"failed to nft balance\", error);\n            });\n    }, [address]);\n\n\n    // This is the case where the user hasn't connected their wallet\n    // to your web app. Let them call connectWallet.\n    if (!address) {\n        return (\n            <div className=\"landing\">\n                <h1>‚òï Welcome to PuneDAO ‚òï</h1>\n                <button onClick={() => connectWallet(\"injected\")} className=\"btn-hero\">\n                    Connect your wallet\n                </button>\n            </div>\n        );\n    }\n    if (hasClaimedNFT) {\n        return (\n            <div className=\"member-page\">\n                <h1>‚òï PuneDAO ‚òï</h1>\n                <p>Congratulations on being a member</p>\n                <div>\n                    <div>\n                        <h2>Member List</h2>\n                        <table className=\"card\">\n                            <thead>\n                            <tr>\n                                <th>Address</th>\n                                <th>Token Amount</th>\n                            </tr>\n                            </thead>\n                            <tbody>\n                            {memberList.map((member) => {\n                                return (\n                                    <tr key={member.address}>\n                                        <td>{shortenAddress(member.address)}</td>\n                                        <td>{member.tokenAmount}</td>\n                                    </tr>\n                                );\n                            })}\n                            </tbody>\n                        </table>\n                    </div>\n                    <div>\n                        <button>Create a new Proposal</button>\n                        <h2>Active Proposals</h2>\n                        <form\n                            onSubmit={async (e) => {\n                                e.preventDefault();\n                                e.stopPropagation();\n\n                                //before we do async things, we want to disable the button to prevent double clicks\n                                setIsVoting(true);\n\n                                // lets get the votes from the form for the values\n                                const votes = proposals.map((proposal) => {\n                                    let voteResult = {\n                                        proposalId: proposal.proposalId,\n                                        //abstain by default\n                                        vote: 2,\n                                    };\n                                    proposal.votes.forEach((vote) => {\n                                        const elem = document.getElementById(\n                                            proposal.proposalId + \"-\" + vote.type\n                                        );\n\n                                        if (elem.checked) {\n                                            voteResult.vote = vote.type;\n                                            return;\n                                        }\n                                    });\n                                    return voteResult;\n                                });\n\n                                // first we need to make sure the user delegates their token to vote\n                                try {\n                                    //we'll check if the wallet still needs to delegate their tokens before they can vote\n                                    const delegation = await tokenModule.getDelegationOf(address);\n                                    // if the delegation is the 0x0 address that means they have not delegated their governance tokens yet\n                                    if (delegation === ethers.constants.AddressZero) {\n                                        //if they haven't delegated their tokens yet, we'll have them delegate them before voting\n                                        await tokenModule.delegateTo(address);\n                                    }\n                                    // then we need to vote on the proposals\n                                    try {\n                                        await Promise.all(\n                                            votes.map(async (vote) => {\n                                                // before voting we first need to check whether the proposal is open for voting\n                                                // we first need to get the latest state of the proposal\n                                                const proposal = await voteModule.get(vote.proposalId);\n                                                // then we check if the proposal is open for voting (state === 1 means it is open)\n                                                if (proposal.state === 1) {\n                                                    // if it is open for voting, we'll vote on it\n                                                    return voteModule.vote(vote.proposalId, vote.vote);\n                                                }\n                                                // if the proposal is not open for voting we just return nothing, letting us continue\n                                                return;\n                                            })\n                                        );\n                                        try {\n                                            // if any of the propsals are ready to be executed we'll need to execute them\n                                            // a proposal is ready to be executed if it is in state 4\n                                            await Promise.all(\n                                                votes.map(async (vote) => {\n                                                    // we'll first get the latest state of the proposal again, since we may have just voted before\n                                                    const proposal = await voteModule.get(\n                                                        vote.proposalId\n                                                    );\n\n                                                    //if the state is in state 4 (meaning that it is ready to be executed), we'll execute the proposal\n                                                    if (proposal.state === 4) {\n                                                        return voteModule.execute(vote.proposalId);\n                                                    }\n                                                })\n                                            );\n                                            // if we get here that means we successfully voted, so let's set the \"hasVoted\" state to true\n                                            setHasVoted(true);\n                                            // and log out a success message\n                                            console.log(\"successfully voted\");\n                                        } catch (err) {\n                                            console.error(\"failed to execute votes\", err);\n                                        }\n                                    } catch (err) {\n                                        console.error(\"failed to vote\", err);\n                                    }\n                                } catch (err) {\n                                    console.error(\"failed to delegate tokens\");\n                                } finally {\n                                    // in *either* case we need to set the isVoting state to false to enable the button again\n                                    setIsVoting(false);\n                                }\n                            }}\n                        >\n                            {proposals.map((proposal, index) => (\n                                <div key={proposal.proposalId} className=\"card\">\n                                    <h5>{proposal.description}</h5>\n                                    <div>\n                                        {proposal.votes.map((vote) => (\n                                            <div key={vote.type}>\n                                                <input\n                                                    type=\"radio\"\n                                                    id={proposal.proposalId + \"-\" + vote.type}\n                                                    name={proposal.proposalId}\n                                                    value={vote.type}\n                                                    //default the \"abstain\" vote to chedked\n                                                    defaultChecked={vote.type === 2}\n                                                />\n                                                <label htmlFor={proposal.proposalId + \"-\" + vote.type}>\n                                                    {vote.label}\n                                                </label>\n                                            </div>\n                                        ))}\n                                    </div>\n                                </div>\n                            ))}\n                            <button disabled={isVoting || hasVoted} type=\"submit\">\n                                {isVoting\n                                    ? \"Voting...\"\n                                    : hasVoted\n                                        ? \"You Already Voted\"\n                                        : \"Submit Votes\"}\n                            </button>\n                            <small>\n                                This will trigger multiple transactions that you will need to\n                                sign.\n                            </small>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    };\n    // This is the case where we have the user's address\n    // which means they've connected their wallet to our site!\n    const mintNft = () => {\n        setIsClaiming(true);\n        // Call bundleDropModule.claim(\"0\", 1) to mint nft to user's wallet.\n        bundleDropModule\n            .claim(\"0\", 1)\n            .catch((err) => {\n                console.error(\"failed to claim\", err);\n                setIsClaiming(false);\n            })\n            .finally(() => {\n                // Stop loading state.\n                setIsClaiming(false);\n                // Set claim state.\n                setHasClaimedNFT(true);\n                // Show user their fancy new NFT!\n                console.log(\n                    `üåä Successfully Minted! Check it out on OpenSea: https://testnets.opensea.io/assets/${bundleDropModule.address}/0`\n                );\n            });\n    }\n\n    // Render mint nft screen.\n    return (\n        <div className=\"mint-nft\">\n            <h1>Mint your free üç™DAO Membership NFT</h1>\n            <button\n                disabled={isClaiming}\n                onClick={() => mintNft()}\n            >\n                {isClaiming ? \"Minting...\" : \"Mint your nft (FREE)\"}\n            </button>\n        </div>\n    );\n};\n\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Import ThirdWeb\nimport { ThirdwebWeb3Provider } from '@3rdweb/hooks';\n\n// Include what chains you wanna support.\n// 4 = Rinkeby.\nconst supportedChainIds = [4];\n\n// Include what type of wallet you want to support.\n// In this case, we support Metamask which is an \"injected wallet\".\nconst connectors = {\n    injected: {},\n};\n\n// Finally, wrap App with ThirdwebWeb3Provider.\nReactDOM.render(\n    <React.StrictMode>\n        <ThirdwebWeb3Provider\n            connectors={connectors}\n            supportedChainIds={supportedChainIds}\n        >\n            <div className=\"landing\">\n                <App />\n            </div>\n        </ThirdwebWeb3Provider>\n    </React.StrictMode>,\n    document.getElementById('root')\n);"],"sourceRoot":""}